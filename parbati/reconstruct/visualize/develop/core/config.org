#+PROPERTY: SRCLOC /Users/vishalsoodmuchu/work/learn/scapes/project/himalaya-forms/parbati/src/cpp

#+title: Config


To configure a model / visualization, we have to specify =parameters=. We develop =class SceneConfig= that acts as a central repository for all settings needed by the various components, allowing us to
- Easily save/load configurations
- Share settings across components without tight coupling
- Modify parameters at runtime through UI controls
- Support command-line arguments for batch rendering or configuration

* Definitions
Let us start defining =class SceneConfig= by listing the libraries and other classes that it will need,
#+name: scene-config-header-includes
#+begin_src cpp :main no :tangle no
#pragma once

#include <memory>                       // std::shared_ptr/std::unique_ptr
#include <functional>                   // std::function
#include <iostream>                     // std::cout, etc.
#include <string>                       // std::string
#include <vector>                       // std::vector
#include <fstream>                      // file operations
#include <random>                       // random number generation
#include <getopt.h>                     // command-line parsing
#include <unordered_map>                // parameter management
#include <cstdint>                      // fixed-width integer types
#include <optional>                     // optional values
#include <variant>                      // variant parameter types

#include "glm/glm.hpp"                  // GLM core
#include "glm/gtc/matrix_transform.hpp" // transformations
#include "glm/gtc/type_ptr.hpp"         // value_ptr

#include "utilities/logger.hpp"

// Forward declarations
class Camera;
class Terrain;
class Light;

#+end_src

** Run settings

We can record a scene's name, description, and other /global/ attributes,
#+name: scene-config-define-RunSettings
#+begin_src cpp :main :no :noweb no :tangle no
struct RunSettings {
    std::string scene_name = "View Himalaya";
    std::string scene_description = "Behold a Himalayan landscape.";
    float global_scale = 1.0f;
    float time_of_day = 12.0f;
    bool enable_simulation = false; //drop this
    float simulation_speed = 1.0f;  //or move to a simulation section
    unsigned int random_seed = 12345; //to seed the random number generator
}
#+end_src

** Viewer window settings

We will define a class to handle the application's windows, and configure it with,
#+name: scene-config-define-WindowSettings
#+begin_src cpp :main no :noweb no :tangle no
struct WindowSettings {
    std::string title = "View Himalaya";
    int width = 1200; int height = 720;
    bool fullscreen = false; bool vsync = true;
    float bg_clear_color[4] = {0.2f, 0.3f, 0.4f, 1.0f}; //background
    int msaa_samples = 4; //multisample-antialiasing
}
#+end_src

** Terrain settings: NOTINCLUDED

We will represent a landscape's terrain with a C++ class and configure it by,
#+name: scene-config-terrain-header
#+begin_src cpp :main no :noweb no :tangle no
struct TerrainSettings {
    bool enabled = true;
    float base_height = 0.0f;
    float height_scale = 500.0f;
    int resolution = 1024;
    float size = 1000.0f;
    std::string height_map_path = "";
    bool use_procedural_terrain = true;
    float base_color[3] = {0.2f, 0.5f, 0.2f};
    float roughness = 0.7f;
    int lod_levels = 5;
    float lod_distance = 500.0f;
    bool wireframe = false;
};
#+end_src

Here we have
- =enabled=: Boolean flag that determines whether terrain rendering is active or disabled
- =base_height=: The starting or minimum elevation of our terrain, essentially representing "sea level" (0.0f by default)
- =height_scale=: A multiplier (500.0f) applied to height values to exaggerate or flatten terrain features
- =resolution=: Defines the grid density (1024x1024 points) of our terrain mesh, affecting detail level
- =height_map_path=: File path to an external heightmap image if we want to load terrain from a file
- =use_procedural_terrain=: Boolean indicating whether to generate terrain procedurally rather than loading from a file
- =base_color=: RGB values (0.2, 0.5, 0.2) representing the default terrain color (a medium green)
- =roughness=: Controls the terrain's surface texture properties (0.7f suggests moderately rough)
- =lod_levels=: Number of Level-of-Detail steps (5) for performance optimization (fewer polygons at distance)
- =lod_distance=: Distance threshold (500.0f units) at which LOD transitions occur
- =wireframe=: Boolean toggle for wireframe visualization mode instead of solid rendering

We set level-of-detail, via =lod_levels=. Level of Detail (LOD) is a crucial optimization technique in our terrain visualization system, especially when rendering vast Himalayan landscapes.

LOD dynamically adjusts the complexity (measured as polygon count) of terrain meshes based on distance from the viewer. Areas closer to the camera receive more detail, while distant regions use simplified representations. We control LOD via two settings,

- =lod_levels = 5=: This defines the number of detail gradations our system will use. With 5 levels, we might have:
  - Level 0: Full resolution (1024×1024 grid) for nearby terrain
  - Level 1: 512×512 grid for intermediate distances
  - Level 2: 256×256 grid
  - Level 3: 128×128 grid
  - Level 4: 64×64 grid for very distant terrain

- =lod_distance = 500.0f=: This parameter defines the distance threshold at which LOD transitions occur. For example:
  - 0-500 units from camera: Level 0 (highest detail)
  - 500-1000 units: Level 1
  - 1000-1500 units: Level 2
  - And so on

Several approaches could be implemented in our system:

1. *Discrete LOD:* Multiple resolution meshes pre-generated and swapped based on distance
2. *Continuous LOD (CLOD):* Smooth transitions between detail levels using techniques like geomorphing
3. *Quadtree/Chunked LOD:* Dividing terrain into quads with different resolutions
4. *Geometry clipmaps:* Concentric rings of terrain at different resolutions centered on the viewer

LOD transitions can sometimes create visual artifacts:
- "Popping" when meshes change resolution
- Texture stretching at lower detail levels
- Inconsistent lighting across LOD boundaries

For our Himalayan visualization, we might want to implement techniques like alpha blending between LOD levels or height-based LOD bias (maintaining higher detail for prominent peaks regardless of distance).

This LOD system will be crucial for maintaining interactive frame rates while exploring vast mountainous landscapes, allowing us to render expansive vistas without overwhelming the GPU.

** Camera settings: NOTINCLUDED

A camera can be fairly complex. We can use the following settings to configure a simple camera,
#+name: scene-config-camera-header
#+begin_src cpp :main no :noweb yes :tangle no
struct CameraSettings {
    glm::vec3 initial_position = glm::vec3(0.0f, 100.0f, 500.0f);
    glm::vec3 initial_target = glm::vec3(0.0f, 0.0f, 0.0f);
    float view_field = 60.0f;
    float near_plane = 0.1f;
    float far_plane = 10000.0f;
    float move_speed = 100.0f;
    float rotate_speed = 0.1f;
    float zoom_speed = 10.0f;
    bool invert_y = false;
    bool terrain_follow = false;
    float terrain_offset = 10.0f;
};
#+end_src
=struct CameraSettings= defines the configuration for a 3D camera in our visualization app. Let's examine each attribute:

1. =initial_position=: A 3D vector defining where the camera starts in world space. The default position (0, 100, 500) places the camera 100 units up on the Y-axis and 500 units back on the Z-axis from the origin.

2. =initial_target=: A 3D vector defining what point the camera is looking at initially. The default (0, 0, 0) has the camera looking at the world origin.

3. =view_field=: The camera's field of view angle in degrees. The 60-degree default is a fairly standard perspective that balances between wide-angle and telephoto views.

4. =near_plane=: The distance to the near clipping plane (0.1 units). Objects closer than this to the camera won't be rendered.

5. =far_plane=: The distance to the far clipping plane (10000 units). Objects farther than this from the camera won't be rendered.

6. =move_speed=: How quickly the camera moves through the scene (100 units per second, most likely) when using keyboard or other movement controls.

7. =rotate_speed=: How quickly the camera rotates (0.1 radians per input unit, presumably) when using mouse or other rotation controls.

8. =zoom_speed=: How quickly the camera zooms in or out (10 units per zoom input) when using scroll wheel or other zoom controls.

9. =invert_y=: A boolean flag to control whether the Y-axis mouse movement is inverted for camera control (false by default).

10. =terrain_follow=: A boolean flag indicating whether the camera should automatically maintain a consistent height above terrain as it moves (false by default).

11. =terrain_offset=: If terrain following is enabled, this defines how many units (10 by default) above the terrain the camera should maintain.

These parameters together define how the camera behaves in our 3D scene, with reasonable defaults for a typical terrain visualization scenario. The settings allow for customization of both the camera's visual properties (field of view, clipping planes) and its control behavior (movement speeds, inversion options, terrain following).

** Lighting settings: NOTINCLUDED
Amount of light available for a landscape scene depends on several environmental factors. Here is a list of settings crucial to render a naturalistic landscape scene,
#+name: scene-config-lighting-header
#+begin_src cpp :main no :noweb yes :tangle no
struct LightingSettings {
    bool  enable_shadows = true;
    int   shadow_map_resolution = 127;
    float ambient_color[3] = {1.0f, 0.9f, 0.8f};
    float ambient_intensity = 0.2f;
    float sun_direction[3] = {0.5f, -0.8f, 0.2f};
    float sun_color[3] = {1.0f, 0.9f, 0.8f};
    float sun_intensity = 1.0f;
    bool  dynamic_time_of_day = false;
    float fog_density = 0.002f;
    float fog_color[3] = {0.8f, 0.9f, 1.0f};
};
#+end_src

=struct LightingSettings= contains parameters that control how light behaves in our landscape visualization. Here's an explanation of each attribute:

1. =enable_shadows= (boolean): Controls whether objects in the scene cast shadows. When true, the renderer calculates shadows, adding realism but requiring more computational resources.

2. =shadow_map_resolution= (int): Determines the resolution/quality of the shadow maps used for shadow rendering. The current value of 0.2f seems unusual as an int should be a whole number - typically this would be something like 1024, 2048, or 4096 pixels. Higher values produce more detailed shadows but require more memory and processing power.

3. =ambient_color[3]= (float array): Defines the color of the ambient light in RGB format. The current warm-tinted white value [1.0, 0.9, 0.8] represents a slightly yellowish/orangish ambient light that fills in shadowed areas.

4. =ambient_intensity= (float): Controls the strength of the ambient light in the scene. At 0.2f, it provides subtle illumination to areas not directly lit by the sun.

5. =sun_direction[3]= (float array): Defines the direction vector of the sun. The values [0.5, -0.8, 0.2] indicate the sun is positioned somewhat to the right (positive x), considerably above (negative y), and slightly forward (positive z) in the scene.

6. =sun_color[3]= (float array): Sets the RGB color of the sunlight. The current value [1.0, 0.9, 0.8] creates a warm, slightly golden sunlight typical of morning or afternoon sun.

7. =sun_intensity= (float): Controls the brightness of the directional sunlight. At 1.0f, it's at full strength.

8. =dynamic_time_of_day= (boolean): When enabled, this would likely animate the sun's position and color over time to simulate the changing lighting conditions throughout the day. Currently disabled.

9. =fog_density= (float): Controls the thickness of atmospheric fog in the scene. At 0.002f, it creates a subtle fog effect that increases with distance, helping with depth perception in landscape scenes.

10. =fog_color[3]= (float array): Sets the RGB color of the fog. The current bluish-white value [0.8, 0.9, 1.0] simulates atmospheric scattering, giving distant objects a bluish tint.

These parameters together create a physically-based lighting model that simulates natural lighting conditions. For our Himalayan landscapes, we might want to adjust these based on the specific conditions we encounter - perhaps increasing fog density for misty mountain scenes, changing the sun direction and color for different times of day, or modifying the ambient color to match the atmospheric conditions of high altitudes.

This struct provides a solid foundation for realistic lighting in our landscape visualization. As we explore the Himalayas, we might consider a few enhancements:

1. Elevation-dependent atmospheric effects - at higher altitudes, the air is clearer and sunlight more intense with a bluer quality
2. Weather-influenced lighting - capturing the dramatic light changes during monsoon periods or the crystal clarity after a storm
3. Time-lapse capabilities - using the =dynamic_time_of_day= to create beautiful transitions from dawn to dusk

We could also consider adding parameters for:
- Volumetric lighting (god rays through clouds/trees)
- Specular reflections for water bodies and snow
- Subsurface scattering for rendering snow fields and glaciers

** Summary

Let us put together the pieces into a =C++= header file,
#+header: :tangle (concat (org-entry-get nil "SRCLOC" t) "/Landscapes/include/core/scene_config.hpp")
#+begin_src cpp :main no :noweb yes
<<scene-config-header-includes>>

/**
 ,* @class SceneConfig
 ,* @brief Configuration container for visual models of landscapes
 ,*  Holds all parameters required to configure different aspects of a
 ,*  landscape scene, organized into logical sections.
,*/
struct SceneConfig {
    <<scene-config-define-RunSettings>>;

    <<scene-config-define-WindowSettings>>;

    RunSettings run;
    WindowSettings window;

    SceneConfig() = default;

    bool load_from_file(const std::string& filename);
    bool save_to_file(const std::string& filename) const;

    void reset_to_defaults();

    bool validate();

    void randomize_aesthetics(unsigned int seed);

    SceneConfig clone() const;

    std::string to_string() const;

    // Parse command line arguments
    void parse_command_line(int argc, char* argv[]);

};
#+end_src

* Load configuration from a file

We will write individual sections of a configuration as a YAML dictionary that we can extract. Each entry will be a possibly nested dictionary itself, and individual elements will need data conversion. Let us go through each of the sections that we have defined in our scene configuration class.

For each config section we can use a function,
#+begin_src cpp :main no :tangle no

#+end_src

** Run
#+name: scene-config-load-run
#+begin_src cpp :main no :tangle no
if (config["Run"]){
    auto gen = config["Run"];
    run.scene_name =
        gen["SceneName"].as<std::string>(run.scene_name);
    run.scene_description =
        gen["SceneDescription"].as<std::string>(run.scene_description);
    run.global_scale =
        gen["GlobalScale"].as<float>(run.global_scale);
    run.random_seed =
        gen["RandomSeed"].as<unsigned int>(run.random_seed);
    run.time_of_day =
        gen["TimeOfDay"].as<float>(run.time_of_day);
    run.enable_simulation =
        gen["EnableSimulation"].as<bool>(run.enable_simulation);
    run.simulation_speed =
        gen["SimulationSpeed"].as<float>(run.simulation_speed);
}
#+end_src

** Window
#+name: scene-config-load-window
#+begin_src cpp :main no :tangle no
if (config["Window"]) {
    auto win = config["Window"];
    window.width =
        win["Width"].as<int>(window.width);
    window.height =
        win["height"].as<int>(window.height);
    window.fullscreen =
        win["FullScreen"].as<bool>(window.fullscreen);
    window.title =
        win["Title"].as<std::string>(window.title);
    window.vsync =
        win["VSync"].as<bool>(window.vsync);
    window.msaa_samples =
        win["MsaaSamples"].as<int>(window.msaa_samples);

    if (win["BackgroundClearColor"]) {
        auto color = win["BackgroundClearColor"];
        for (int i = 0; i < 4 && i < color.size(); i++) {
            window.bg_clear_color[i] = color[i].as<float>();
        }
    }
}
#+end_src

** UI: NOTINCLUDED
#+name: scene-config-load-ui
#+begin_src cpp :main no :tangle no
if (config["UI"]) {
    auto ui_config = config["UI"];
    ui.show_ui =
        ui_config["ShowUI"].as<bool>(ui.show_ui);
    ui.show_fps =
        ui_config["ShowFPS"].as<bool>(ui.show_fps);
    ui.show_coords =
        ui_config["ShowCoordinates"].as<bool>(ui.show_coords);
    ui.show_control_help =
        ui_config["ShowControlHelp"].as<bool>(ui.show_control_help);
    ui.ui_scale =
        ui_config["UIScale"].as<float>(ui.ui_scale);
    ui.dark_theme =
        ui_config["DarkTheme"].as<bool>(ui.dark_theme);
    ui.show_debug_info =
        ui_config["ShowDebugInfo"].as<bool>(ui.show_debug_info);
}
#+end_src

** Terrain: NOTINCLUDED
#+name: scene-config-load-terrain
#+begin_src cpp :main no :tangle no
if (config["Terrain"]) {
    auto terr = config["Terrain"];
    terrain.enabled =
        terr["Enabled"].as<bool>(terrain.enabled);
    terrain.base_height =
        terr["BaseHeight"].as<float>(terrain.base_height);
    terrain.height_scale =
        terr["HeightScale"].as<float>(terrain.height_scale);
    terrain.resolution =
        terr["Resolution"].as<int>(terrain.resolution);
    terrain.height_map_path =
        terr["HeightmapPath"].as<std::string>(terrain.height_map_path);
    terrain.use_procedural_terrain =
        terr["UseProceduralTerrain"].as<bool>(terrain.use_procedural_terrain);

    if (terr["BaseColor"]) {
        auto color = terr["BaseColor"];
        for (int i = 0; i < 3 && i < color.size(); i++) {
            terrain.base_color[i] = color[i].as<float>();
        }
    }

    terrain.roughness =
        terr["Roughtness"].as<float>(terrain.roughness);
    terrain.lod_levels =
        terr["LodLevels"].as<int>(terrain.lod_levels);
    terrain.lod_distance =
        terr["LodDistance"].as<float>(terrain.lod_distance);
    terrain.wireframe =
        terr["WireFrame"].as<bool>(terrain.wireframe);
}
#+end_src

** Camera: NOTINCLUDED
#+name: scene-config-load-camera
#+begin_src cpp :main no :tangle no
if (config["Camera"]) {
    auto cam = config["camera"];

    if (cam["InitialPosition"]) {
        camera.initial_position =
            cam["InitialPosition"].as<glm::vec3>();}
    if (cam["InitialTarget"]) {
        camera.initial_target =
            cam["InitialTarget"].as<glm::vec3>();}
    camera.view_field =
        cam["FieldOfView"].as<float>(camera.view_field);
    camera.near_plane =
        cam["NearPlane"].as<float>(camera.near_plane);
    camera.far_plane =
        cam["FarPlane"].as<float>(camera.far_plane);
    camera.move_speed =
        cam["MoveSpeed"].as<float>(camera.move_speed);
    camera.rotate_speed =
        cam["RotateSpeed"].as<float>(camera.rotate_speed);
    camera.zoom_speed =
        cam["ZoomSpeed"].as<float>(camera.zoom_speed);
    camera.invert_y =
        cam["InvertY"].as<bool>(camera.invert_y);
    camera.terrain_follow =
        cam["TerrainFollow"].as<bool>(camera.terrain_follow);
    camera.terrain_offset =
        cam["TerrainOffset"].as<float>(camera.terrain_offset);
}
#+end_src

** Lighting: NOTINCLUDED
#+name: scene-config-load-lighting
#+begin_src cpp :main no :tangle no
if (config["Lighting"]) {
    auto light = config["lighting"];

    lighting.enable_shadows =
        light["EnableShadows"].as<bool>(lighting.enable_shadows);
    lighting.shadow_map_resolution =
        light["ShadowMapResolution"].as<int>(lighting.shadow_map_resolution);
    lighting.ambient_intensity =
        light["AmbientIntenity"].as<float>(lighting.ambient_intensity);

    if (light["AmbientColor"]) {
        auto color = light["AmbientColor"];
        for (int i = 0; i < 3 && i < color.size(); i++) {
            lighting.sun_direction[i] = color[i].as<float>();}}

    if (light["SunDirection"]) {
        auto direction = light["SunDirection"];
        for (int i = 0; i < 3 && i < direction.size(); i++) {
            lighting.sun_direction[i] = direction[i].as<float>();}}

    if (light["SunColor"]) {
        auto color = light["SunColor"];
        for (int i = 0; i < 3 && i < color.size(); i++) {
            lighting.sun_color[i] = color[i].as<float>();}}

    lighting.sun_intensity =
        light["SunIntensity"].as<float>(lighting.sun_intensity);
    lighting.dynamic_time_of_day =
        light["DynamicTimeOfDay"].as<bool>(lighting.dynamic_time_of_day);
    lighting.fog_density =
        light["FogDensity"].as<float>(lighting.fog_density);

    if (light["FogColor"]) {
        auto color = light["FogColor"];
        for (int i = 0; i < 3 && i < color.size(); i++){
            lighting.fog_color[i] = color[i].as<float>();}}
}
#+end_src

** Summary
We will use =.yaml= format to encode a scene's configuration. Once we have
#+name: scene-config-load
#+begin_src cpp :main no :noweb yes :tangle no
bool SceneConfig::load_from_file(const std::string& filename) {
    try {
        YAML::Node config = YAML::LoadFile(filename);

        <<scene-config-load-run>>

        <<scene-config-load-window>>

        return validate();
    } catch (const YAML::Exception& e) {
        std::cerr << "Error loading configuration: " << e.what() << std::endl;
        return false;
    }
}
#+end_src

* Command line interface

#+name: scene-config-parse-command-line
#+begin_src cpp :main no :tangle no
void SceneConfig::parse_command_line(int argc, char* argv[]) {
    // Define the expected options
    static struct option long_options[] = {
        {"width", required_argument, 0, 'w'},
        {"height", required_argument, 0, 'h'},
        {"config", required_argument, 0, 'c'},
        {"help", no_argument, 0, '?'},
        {0, 0, 0, 0}
    };

    int option_index = 0;
    int c;

    // Parse options
    while ((c = getopt_long(argc, argv, "w:h:c:?", long_options, &option_index)) != -1) {
        switch (c) {
            case 'w':
                // Set window width
                window.width = std::stoi(optarg);
                break;
            case 'h':
                // Set window height
                window.height = std::stoi(optarg);
                break;
            case 'c':
                // Set config file path
                load_from_file(optarg);
                break;
            case '?':
                // Display help
                std::cout << "Usage: " << argv[0] << " [OPTIONS]\n"
                          << "Options:\n"
                          << "  -w, --width=WIDTH      Set window width\n"
                          << "  -h, --height=HEIGHT    Set window height\n"
                          << "  -c, --config=FILE      Specify configuration file\n"
                          << "  -?, --help             Display this help message\n";
                exit(0);
                break;
            default:
                break;
        }
    }

    // Process any remaining arguments
    for (int i = optind; i < argc; i++) {
        std::cout << "Non-option argument: " << argv[i] << std::endl;
    }
}
#+end_src

For the CLI interface of =SceneConfig=, we can break down the key attributes:

1. Options Definition:
   - The code uses =struct option= to define long-form command-line options
   - Each option has four components:
     a. Option name (string)
     b. Argument requirement (=required_argument= or =no_argument=)
     c. A pointer to store the flag (set to 0 here)
     d. A short option character

2. Parsing Mechanism:
   - Uses =getopt_long()= for flexible command-line argument parsing
   - Supports both short (=-w=) and long (=--width=) option formats
   - Handles different option types:
     - Width setting
     - Height setting
     - Configuration file loading
     - Help display

3. Error Handling:
   - Provides a help message when =-?= or =--help= is used
   - Allows for graceful exit with usage instructions

For our Himalayan journey, we could extend this CLI approach to configure our computational and artistic tools. For instance, we might add options to:
- Set data collection parameters
- Configure artistic rendering modes
- Specify geographic regions of interest
- Toggle between research and artistic data capture modes

Our project could benefit from a flexible CLI that allows dynamic reconfiguration of our computational and artistic tools during the expedition.

* Save to file

To save the config to =.yaml= file we will need to save individual sections,
#+name: scene-config-save-to-file
#+begin_src cpp :main no :noweb yes :tangle no
bool SceneConfig::save_to_file(const std::string& filename) const {
    try {
        YAML::Node config;

        <<scene-config-save-run>>

        <<scene-config-save-window>>

        std::ofstream fout(filename);
        if (!fout.is_open()) {
            std::cerr << "Failed to open file for writing" << filename << std::endl;
            return false;
        }
        fout << config;
        return true;
    } catch (const std::exception& e) {
        std::cerr << "Error saving configuration" << e.what() << std::endl;
    }
}

void SceneConfig::reset_to_defaults() {
    *this = SceneConfig();
}
#+end_src

for which we have to implement a savior for each section.

** Run
#+name: scene-config-save-run
#+begin_src cpp :main no :tangle no
YAML::Node run_node;
run_node["SceneName"] = run.scene_name;
run_node["SceneDescription"] = run.scene_description;
run_node["GlobalScale"] = run.global_scale;
run_node["RandomSeed"] = run.random_seed;
run_node["TimeOfDay"] = run.time_of_day;
run_node["EnableSimulation"] = run.enable_simulation;
run_node["SimulationSpeed"] = run.simulation_speed;
config["Run"] = run_node;
#+end_src

** Window
#+name: scene-config-save-window
#+begin_src cpp :main no :tangle no
YAML::Node window_node;
window_node["Width"] = window.width;
window_node["Height"] = window.height;
window_node["Fullscreen"] = window.fullscreen;
window_node["Title"] = window.title;
window_node["VSync"] = window.vsync;
window_node["MsaaSamples"] = window.msaa_samples;

YAML::Node bg_color;
for (int i = 0; i < 4; i++) {
    bg_color.push_back(window.bg_clear_color[i]);
}
window_node["BackgroundClearColor"] = bg_color;
config["Window"] = window_node;
#+end_src

** UI: NOTINCLUDED
#+name: scene-config-save-ui
#+begin_src cpp :main no :tangle no
YAML::Node ui_node;
ui_node["ShowUI"] = ui.show_ui;
ui_node["ShowFPS"] = ui.show_fps;
ui_node["ShowCoordinates"] = ui.show_coords;
ui_node["ShowControlHelp"] = ui.show_control_help;
ui_node["UIScale"] = ui.ui_scale;
ui_node["DarkTheme"] = ui.dark_theme;
ui_node["ShowDebugInfo"] = ui.show_debug_info;
config["UI"] = ui_node;

#+end_src

** Terrain: NOTINCLUDED
#+name: scene-config-save-terrain
#+begin_src cpp :main no :tangle no
// Save Terrain Settings
YAML::Node terrain_node;
terrain_node["Enabled"] = terrain.enabled;
terrain_node["BaseHeight"] = terrain.base_height;
terrain_node["HeightScale"] = terrain.height_scale;
terrain_node["Resolution"] = terrain.resolution;
terrain_node["HeightmapPath"] = terrain.height_map_path;
terrain_node["UseProceduralTerrain"] = terrain.use_procedural_terrain;

YAML::Node base_color;
for (int i = 0; i < 3; i++) {
    base_color.push_back(terrain.base_color[i]);
}
terrain_node["BaseColor"] = base_color;
terrain_node["Roughness"] = terrain.roughness;
terrain_node["LodLevels"] = terrain.lod_levels;
terrain_node["LodDistance"] = terrain.lod_distance;
terrain_node["Wireframe"] = terrain.wireframe;
config["Terrain"] = terrain_node;
#+end_src

** Camera: NOTINCLUDED
#+name: scene-config-save-camera
#+begin_src cpp :main no :tangle no
// Save Camera Settings
YAML::Node camera_node;
camera_node["InitialPosition"] = camera.initial_position;
camera_node["InitialTarget"] = camera.initial_target;
camera_node["FieldOfView"] = camera.view_field;
camera_node["NearPlane"] = camera.near_plane;
camera_node["FarPlane"] = camera.far_plane;
camera_node["MoveSpeed"] = camera.move_speed;
camera_node["RotateSpeed"] = camera.rotate_speed;
camera_node["ZoomSpeed"] = camera.zoom_speed;
camera_node["InvertY"] = camera.invert_y;
camera_node["TerrainFollow"] = camera.terrain_follow;
camera_node["TerrainOffset"] = camera.terrain_offset;
config["Camera"] = camera_node;
#+end_src

** Lighting: NOTINCLUDED
#+name: scene-config-save-lighting
#+begin_src cpp :main no :tangle no
YAML::Node lighting_node;
lighting_node["EnableShadows"] = lighting.enable_shadows;
lighting_node["ShadowMapResolution"] = lighting.shadow_map_resolution;
lighting_node["AmbientIntensity"] = lighting.ambient_intensity;

YAML::Node ambient_color;
for (int i = 0; i < 3; i++) {
    ambient_color.push_back(lighting.ambient_color[i]);
}
lighting_node["AmbientColor"] = ambient_color;

YAML::Node sun_dir;
for (int i = 0; i < 3; i++) {
    sun_dir.push_back(lighting.sun_direction[i]);
}
lighting_node["SunDirection"] = sun_dir;

YAML::Node sun_color;
for (int i = 0; i < 3; i++) {
    sun_color.push_back(lighting.sun_color[i]);
}
lighting_node["SunColor"] = sun_color;

lighting_node["SunIntensity"] = lighting.sun_intensity;
lighting_node["DynamicTimeOfDay"] = lighting.dynamic_time_of_day;
lighting_node["FogDensity"] = lighting.fog_density;

YAML::Node fog_color;
for (int i = 0; i < 3; i++) {
    fog_color.push_back(lighting.fog_color[i]);
}
lighting_node["FogColor"] = fog_color;
config["Lighting"] = lighting_node;
#+end_src

** To string
We can use the same code to define a conversion of the config to a string,
#+name: scene-config-to-string
#+begin_src cpp :main no :noweb yes :tangle no
std::string SceneConfig::to_string() const {
    try {
        YAML::Node config;

        <<scene-config-save-run>>;

        <<scene-config-save-window>>;

        std::stringstream ss;
        ss << config;
        return ss.str();
    } catch (const std::exception& e) {
        std::cerr << "Error saving configuration" << e.what() << std::endl;
    }
}
#+end_src

* Validate
We should validate the config.
#+name: scene-config-validate
#+begin_src cpp :main no :tangle no
bool SceneConfig::validate() {
    bool valid = true;

    if (run.global_scale <= 0.0f) {
        run.global_scale = 1.0f;
        valid = false;}

    if (run.time_of_day < 0.0f || run.time_of_day > 24.0f) {
        run.time_of_day = fmod(run.time_of_day, 24.0f);
        if (run.time_of_day <0) run.time_of_day += 24.0f;
        valid = false;}

    if (run.simulation_speed < 0.0f) {
        run.simulation_speed = 1.0f;
        valid = false;}

    if (window.width < 320) {
        window.width = 320;
        valid = false;}

    if (window.height < 240) {
        window.height = 240;
        valid = false;}

    if (window.msaa_samples < 0) {
        window.msaa_samples = 0;
        valid = false;}

    if (window.msaa_samples > 16) {
        window.msaa_samples = 16;
        valid = false;}

    return valid;
}
#+end_src

** Example with more sections
#+begin_src cpp :main no :tangle no
bool SceneConfig::validate() {
    bool valid = true;

    if (run.global_scale <= 0.0f) {
        run.global_scale = 1.0f;
        valid = false;}

    if (run.time_of_day < 0.0f || run.time_of_day > 24.0f) {
        run.time_of_day = fmod(run.time_of_day, 24.0f);
        if (run.time_of_day <0) run.time_of_day += 24.0f;
        valid = false;}

    if (run.simulation_speed < 0.0f) {
        run.simulation_speed = 1.0f;
        valid = false;}

    if (window.width < 320) {
        window.width = 320;
        valid = false;}

    if (window.height < 240) {
        window.height = 240;
        valid = false;}

    if (window.msaa_samples < 0) {
        window.msaa_samples = 0;
        valid = false;}

    if (window.msaa_samples > 16) {
        window.msaa_samples = 16;
        valid = false;}

    if (ui.ui_scale <= 0.0f) {
        ui.ui_scale = 1.0f;
        valid = false;}

    if (terrain.height_scale <= 0.0f) {
        terrain.height_scale = 1.0f;
        valid = false;}

    if (terrain.roughness < 0.0f || terrain.roughness > 1.0f) {
        terrain.roughness = glm::clamp(terrain.roughness, 0.0f, 1.0f);
        valid = false;}

    if (terrain.lod_levels < 1) {
        terrain.lod_levels = 1;
        valid = false;
    } else if (terrain.lod_levels > 0) {
        terrain.lod_levels = 8;
        valid = false;}

    if (terrain.lod_distance <= 0.0f) {
        terrain.lod_distance = 100.0f;
        valid = false;}

    if (camera.view_field <= 0.0f || camera.view_field > 100.0f) {
        camera.view_field = glm::clamp(camera.view_field, 1.0f, 179.0f);
        valid = false;}

    if (camera.near_plane <= 0.0f) {
        camera.near_plane = 0.1f;
        valid = false;}

    if (camera.far_plane <= camera.near_plane) {
        camera.far_plane = 1000.0f * camera.near_plane;
        valid = false;}

    if (camera.rotate_speed <= 0.0f) {
        camera.rotate_speed = 0.1f;
        valid = false;}

    if (camera.zoom_speed <= 0.0f) {
        camera.zoom_speed = 1.0f;
        valid = false;}

    if (camera.terrain_offset < 0.0f) {
        camera.terrain_offset = 1.0f;
        valid = false;}

    if (lighting.shadow_map_resolution < 512) {
        lighting.shadow_map_resolution = 512;
        valid = false;
    } else if (lighting.shadow_map_resolution > 8192) {
        lighting.shadow_map_resolution = 8192;
        valid = false;}

    if ((lighting.shadow_map_resolution
        & (lighting.shadow_map_resolution - 1)) != 0) {
        lighting.shadow_map_resolution =
            1 << static_cast<int>(ceil(log2(lighting.shadow_map_resolution)));
        valid = false;}

    if (lighting.ambient_intensity < 0.0f) {
        lighting.ambient_intensity = 0.0f;
        valid = false;}

    if (lighting.sun_intensity < 0.0f) {
        lighting.sun_intensity = 0.0f;
        valid = false;}

    if (lighting.fog_density < 0.0f) {
        lighting.fog_density = 0.0f;
        valid = false;}

    for (int i = 0; i < 4; i++) {
        terrain.base_color[i] = glm::clamp(terrain.base_color[i], 0.0f, 1.0f);
        lighting.ambient_color[i] = glm::clamp(lighting.ambient_color[i], 0.0f, 1.0f);
        lighting.sun_color[i] = glm::clamp(lighting.sun_color[i], 0.0f, 1.0f);
        lighting.fog_color[i] = glm::clamp(lighting.fog_color[i], 0.0f, 1.0f);}

    float norm_sun_dir =
        sqrt(lighting.sun_direction[0] * lighting.sun_direction[0]
             + lighting.sun_direction[1] * lighting.sun_direction[1]
             + lighting.sun_direction[2] * lighting.sun_direction[2]);

    if (norm_sun_dir > 0.0001f) {
        for (int i = 0; i < 3; i++) {
            lighting.sun_direction[i] /= norm_sun_dir;}
    } else {
        lighting.sun_direction[0] = 0.0f;
        lighting.sun_direction[1] = -1.0f;
        lighting.sun_direction[2] = 0.0f;
        valid = false;}

    return valid;
}
#+end_src

* Randomize

If we can randomize a ~SceneConfig~, we can re-display the visualization for a fresh perspective,
#+name: scene-config-randomize
#+begin_src cpp :main no :tangle no
void SceneConfig::randomize_aesthetics(unsigned int seed) {
    std::mt19937 rng(seed != 0 ? seed : std::random_device()());
    std::uniform_real_distribution<float> dist_uniform(0.0f, 1.0f);
    std::uniform_real_distribution<float> dist_color(0.2f, 0.8f);

    run.time_of_day = 24.0f * dist_uniform(rng);

    run.random_seed = seed;
}
#+end_src

#+RESULTS: config-randomize

* Package

We have developed ~class SceneConfig~ methods in small source-code-blocks. Assembling them we can have a complete definition that we can =tangle= to a single source file,
#+header: :tangle (concat (org-entry-get nil "SRCLOC" t) "/Landscapes/source/core/scene_config.cpp")
#+begin_src cpp :main no :noweb yes
#include "core/scene_config.hpp"
#include "templates/yaml.hpp"
#include <fstream>
#include <iostream>
#include <random>
#include <getopt.h> // For command-line parsing

<<scene-config-load>>

<<scene-config-parse-command-line>>

<<scene-config-save-to-file>>

<<scene-config-to-string>>

<<scene-config-validate>>

<<scene-config-randomize>>
#+end_src

* Default config
#+name: config-default-yaml
#+header: :tangle (concat (org-entry-get nil "SRCLOC" t) "/Landscapes/config/default_scene.yaml")
#+begin_src yaml :tangle ./default_scene.yaml
# Default Scene Configuration for Himalayan Landscapes Visualization

Run:
  SceneName: "Himalayan Valley"
  SceneDescription: "Default visualization of a Himalayan mountain landscape"
  GlobalScale: 1.0
  RandomSeed: 12345
  TimeOfDay: 10.0
  EnableSimulation: true
  SimulationSpeed: 1.0

Window:
  Width: 1280
  Height: 720
  Fullscreen: false
  Title: "Himalayan Landscapes"
  VSync: true
  MsaaSamples: 4
  BackgroundClearColor: [0.5, 0.6, 0.7, 1.0]
#+end_src

** Example with more sections
#+begin_src yaml :tangle ./default_scene.yaml
# Default Scene Configuration for Himalayan Landscapes Visualization

Run:
  SceneName: "Himalayan Valley"
  SceneDescription: "Default visualization of a Himalayan mountain landscape"
  GlobalScale: 1.0
  RandomSeed: 12345
  TimeOfDay: 10.0
  EnableSimulation: true
  SimulationSpeed: 1.0

Window:
  Width: 1280
  Height: 720
  Fullscreen: false
  Title: "Himalayan Landscapes"
  VSync: true
  MsaaSamples: 4
  BackgroundClearColor: [0.5, 0.6, 0.7, 1.0]

UI:
  ShowUI: true
  ShowFPS: true
  ShowCoordinates: true
  ShowControlHelp: true
  UIScale: 1.0
  DarkTheme: true
  ShowDebugInfo: false

Terrain:
  Enabled: true
  BaseHeight: 0.0
  HeightScale: 500.0
  Resolution: 1024
  HeightmapPath: ""
  UseProceduralTerrain: true
  BaseColor: [0.5, 0.45, 0.4]
  Roughness: 0.7
  LodLevels: 5
  LodDistance: 500.0
  Wireframe: false

Camera:
  InitialPosition: [500.0, 300.0, 500.0]
  InitialTarget: [0.0, 0.0, 0.0]
  FieldOfView: 60.0
  NearPlane: 0.1
  FarPlane: 10000.0
  MoveSpeed: 100.0
  RotateSpeed: 0.1
  ZoomSpeed: 10.0
  InvertY: false
  TerrainFollow: false
  TerrainOffset: 10.0

Lighting:
  EnableShadows: true
  ShadowMapResolution: 2048
  AmbientIntensity: 0.3
  AmbientColor: [0.6, 0.7, 0.9]
  SunDirection: [0.5, -0.8, 0.2]
  SunColor: [1.0, 0.95, 0.8]
  SunIntensity: 1.0
  DynamicTimeOfDay: true
  FogDensity: 0.00025
  FogColor: [0.75, 0.85, 0.9]

Water:
  Enabled: true
  Height: 50.0
  Color: [0.0, 0.3, 0.5]
  Transparency: 0.7
  WaveHeight: 0.2
  WaveSpeed: 0.05
  Reflectivity: 0.6

Vegetation:
  Enabled: true
  TreeDensity: 0.02
  GrassDensity: 0.6
  TreeTypes: 3
  MaxTrees: 5000
  MaxGrass: 100000
  WindEffect: true

Atmosphere:
  CloudCoverage: 0.3
  CloudHeight: 1000.0
  CloudSpeed: 5.0
  SkyIntensity: 1.0
#+end_src

* YAML specialization
To configure our application using YAML we will need to convert data to =YAML-types=  by parameterizing a template,
#+name: name-specialize-yaml-header
#+header: :tangle (concat (org-entry-get nil "SRCLOC" t) "/Landscapes/include/templates/yaml.hpp")
#+begin_src cpp :main no :noweb no :tangle ../../include/yaml.hpp
#pragma once

#include <yaml-cpp/yaml.h>
#include "glm/glm.hpp"

namespace YAML {
    template <>
    struct convert<glm::vec3> {
        static Node encode (const glm::vec3& v) {
            Node node;
            node.push_back(v.x);
            node.push_back(v.y);
            node.push_back(v.z);
            return node;
        }

        static bool decode(const Node& node, glm::vec3& v) {
            if (!node.IsSequence() || node.size() != 3) {
                return false;}
            v.x = node[0].as<float>();
            v.y = node[1].as<float>();
            v.z = node[2].as<float>();
            return true;
        }
    };
}
#+end_src
